<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Rogue Wave Views Foundation Package: ilviews/util/util.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="roguewave.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table border="0" cellpadding="4" cellspacing="0" width="100%">
  <tbody>
    <tr>
      <td id="projectlogo"><img alt="Rogue Wave logo" src="rwlogo.gif"/></td>
      <td id="projectname">Rogue Wave Views<br/>Foundation Package API Reference Guide</td>
      <td valign="middle"><font color="#003399"><center><b>Product Documentation:</b></font><br/><br/><b><a HREF="../../views.html" target="_top">Rogue Wave Views<br/>Documentation Home</a></b></center></td>
    </tr>
  </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_f1fed744a3af9d84a06b8e8ced3f1fdd.html">ilviews</a></li><li class="navelem"><a class="el" href="dir_4d131fc2f9dac96ed39c26b6d1501060.html">util</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">util.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Utility functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="ilv_8h.html">ilviews/ilv.h</a>&gt;</code><br />
<code>#include &lt;ilviews/base/array.h&gt;</code><br />
<code>#include &lt;ilviews/base/iostream.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af77645baba4325a69d90926e954a20b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#af77645baba4325a69d90926e954a20b7">IlvComputeArcBBox</a> (const <a class="el" href="classIlvRect.html">IlvRect</a> &amp;rect, <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a47ead22a1022daec50724a367b02b842">IlFloat</a> start, <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a47ead22a1022daec50724a367b02b842">IlFloat</a> range, <a class="el" href="classIlvRect.html">IlvRect</a> &amp;bbox)</td></tr>
<tr class="memdesc:af77645baba4325a69d90926e954a20b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bounding box of a portion of an ellipse.  <a href="#af77645baba4325a69d90926e954a20b7">More...</a><br /></td></tr>
<tr class="separator:af77645baba4325a69d90926e954a20b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1543e5c5654cf6a999f68a7758f2666"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ae1543e5c5654cf6a999f68a7758f2666">IlvComputeArrow</a> (const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;from, const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;to, <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a47ead22a1022daec50724a367b02b842">IlFloat</a> atpos, <a class="el" href="classIlvPoint.html">IlvPoint</a> *points, <a class="el" href="Views_2include_8doc_2ilviews_2macros_8h.html#a6304764dd4460c4a474aa7843ac0e194">IlvDim</a> arrowBase=4, <a class="el" href="Views_2include_8doc_2ilviews_2macros_8h.html#a6304764dd4460c4a474aa7843ac0e194">IlvDim</a> arrowLength=8)</td></tr>
<tr class="memdesc:ae1543e5c5654cf6a999f68a7758f2666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the points that define an arrow on a segment.  <a href="#ae1543e5c5654cf6a999f68a7758f2666">More...</a><br /></td></tr>
<tr class="separator:ae1543e5c5654cf6a999f68a7758f2666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d25ccfcfce2290ca453a2f33cbe0d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIlvPoint.html">IlvPoint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a70d25ccfcfce2290ca453a2f33cbe0d3">IlvCreateClosedSpline</a> (<a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a1653965b0ba3aba43e2268d9825390ed">IlUInt</a> count, const <a class="el" href="classIlvPoint.html">IlvPoint</a> *points, <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a1653965b0ba3aba43e2268d9825390ed">IlUInt</a> &amp;totalCount)</td></tr>
<tr class="memdesc:a70d25ccfcfce2290ca453a2f33cbe0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an array of points defining a closed B&eacute;zier spline.  <a href="#a70d25ccfcfce2290ca453a2f33cbe0d3">More...</a><br /></td></tr>
<tr class="separator:a70d25ccfcfce2290ca453a2f33cbe0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42fcf58bed9a2a32b4558ef541bfc54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIlvPoint.html">IlvPoint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ab42fcf58bed9a2a32b4558ef541bfc54">IlvCreateOpenSpline</a> (<a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a1653965b0ba3aba43e2268d9825390ed">IlUInt</a> count, const <a class="el" href="classIlvPoint.html">IlvPoint</a> *points, <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a1653965b0ba3aba43e2268d9825390ed">IlUInt</a> &amp;totalCount)</td></tr>
<tr class="memdesc:ab42fcf58bed9a2a32b4558ef541bfc54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an array of points defining an open B&eacute;zier spline.  <a href="#ab42fcf58bed9a2a32b4558ef541bfc54">More...</a><br /></td></tr>
<tr class="separator:ab42fcf58bed9a2a32b4558ef541bfc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c634c63885d82f3b3407a99b60a55b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ad3c634c63885d82f3b3407a99b60a55b">IlvIntersectHorizontal</a> (const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;point, const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;from, const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;to, <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a3bc8f2226932e099ef97a8474e9bbdcb">IlInt</a> *dir=0)</td></tr>
<tr class="memdesc:ad3c634c63885d82f3b3407a99b60a55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>IlTrue</code> if the horizontal line intercepts the segment.  <a href="#ad3c634c63885d82f3b3407a99b60a55b">More...</a><br /></td></tr>
<tr class="separator:ad3c634c63885d82f3b3407a99b60a55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0d4a4597646fd4d748da948e4ccb76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#afe0d4a4597646fd4d748da948e4ccb76">IlvLinesIntersect</a> (const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;from1, const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;to1, const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;from2, const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;to2, <a class="el" href="classIlvPoint.html">IlvPoint</a> *result=0)</td></tr>
<tr class="memdesc:afe0d4a4597646fd4d748da948e4ccb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>IlTrue</code> if there is an intersection point between two lines.  <a href="#afe0d4a4597646fd4d748da948e4ccb76">More...</a><br /></td></tr>
<tr class="separator:afe0d4a4597646fd4d748da948e4ccb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef401e2a0f6a77b7a54ea9b195cf7d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a3ef401e2a0f6a77b7a54ea9b195cf7d6">IlvPointInClosedSpline</a> (const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;p, <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a1653965b0ba3aba43e2268d9825390ed">IlUInt</a> count, const <a class="el" href="classIlvPoint.html">IlvPoint</a> *points)</td></tr>
<tr class="memdesc:a3ef401e2a0f6a77b7a54ea9b195cf7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>IlTrue</code> if the point is in a closed spline.  <a href="#a3ef401e2a0f6a77b7a54ea9b195cf7d6">More...</a><br /></td></tr>
<tr class="separator:a3ef401e2a0f6a77b7a54ea9b195cf7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0383645b3da710234e76cf5c04f06399"><td class="memItemLeft" align="right" valign="top"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a0383645b3da710234e76cf5c04f06399">IlvPointInFilledSpline</a> (const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;p, <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a1653965b0ba3aba43e2268d9825390ed">IlUInt</a> count, const <a class="el" href="classIlvPoint.html">IlvPoint</a> *points, <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a> windingRule=<a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a3e44d254cb5a7c404f4c9acb50135411">IlFalse</a>)</td></tr>
<tr class="memdesc:a0383645b3da710234e76cf5c04f06399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>IlTrue</code> if the point is in a filled spline.  <a href="#a0383645b3da710234e76cf5c04f06399">More...</a><br /></td></tr>
<tr class="separator:a0383645b3da710234e76cf5c04f06399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267f76ffd56641fe7688a4f5211e6fae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a267f76ffd56641fe7688a4f5211e6fae">IlvPointInLine</a> (const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;p, const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;from, const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;to)</td></tr>
<tr class="memdesc:a267f76ffd56641fe7688a4f5211e6fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>IlTrue</code> if the point is in a line.  <a href="#a267f76ffd56641fe7688a4f5211e6fae">More...</a><br /></td></tr>
<tr class="separator:a267f76ffd56641fe7688a4f5211e6fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bcaebcbf50dc68e021321a7a7e96d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a98bcaebcbf50dc68e021321a7a7e96d2">IlvPointInPolygon</a> (const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;p, <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a1653965b0ba3aba43e2268d9825390ed">IlUInt</a> count, const <a class="el" href="classIlvPoint.html">IlvPoint</a> *poly, <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a> windingRule=<a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a3e44d254cb5a7c404f4c9acb50135411">IlFalse</a>)</td></tr>
<tr class="memdesc:a98bcaebcbf50dc68e021321a7a7e96d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>IlTrue</code> if the point is in a polygon.  <a href="#a98bcaebcbf50dc68e021321a7a7e96d2">More...</a><br /></td></tr>
<tr class="separator:a98bcaebcbf50dc68e021321a7a7e96d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834cfdc36f1ee08daee4bf173b74f5aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a834cfdc36f1ee08daee4bf173b74f5aa">IlvPointInPolyline</a> (const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;p, <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a1653965b0ba3aba43e2268d9825390ed">IlUInt</a> count, const <a class="el" href="classIlvPoint.html">IlvPoint</a> *poly)</td></tr>
<tr class="memdesc:a834cfdc36f1ee08daee4bf173b74f5aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>IlTrue</code> if the point is in a polyline.  <a href="#a834cfdc36f1ee08daee4bf173b74f5aa">More...</a><br /></td></tr>
<tr class="separator:a834cfdc36f1ee08daee4bf173b74f5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9535ee17f6299d78b5f8bbdd14967f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a7b9535ee17f6299d78b5f8bbdd14967f">IlvPointInSpline</a> (const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;p, <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a1653965b0ba3aba43e2268d9825390ed">IlUInt</a> count, const <a class="el" href="classIlvPoint.html">IlvPoint</a> *points)</td></tr>
<tr class="memdesc:a7b9535ee17f6299d78b5f8bbdd14967f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>IlTrue</code> if the point is in a spline.  <a href="#a7b9535ee17f6299d78b5f8bbdd14967f">More...</a><br /></td></tr>
<tr class="separator:a7b9535ee17f6299d78b5f8bbdd14967f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf1ac8ce1052e1db79a64284cc2d1ee"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a0bf1ac8ce1052e1db79a64284cc2d1ee">IlvReadString</a> (istream &amp;is, char *buffer=0)</td></tr>
<tr class="memdesc:a0bf1ac8ce1052e1db79a64284cc2d1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string from an input stream.  <a href="#a0bf1ac8ce1052e1db79a64284cc2d1ee">More...</a><br /></td></tr>
<tr class="separator:a0bf1ac8ce1052e1db79a64284cc2d1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f30c7752c68730b214f341f32e5dd4a"><td class="memItemLeft" align="right" valign="top">istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a8f30c7752c68730b214f341f32e5dd4a">IlvSkipSpaces</a> ()</td></tr>
<tr class="memdesc:a8f30c7752c68730b214f341f32e5dd4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip spaces in a stream.  <a href="#a8f30c7752c68730b214f341f32e5dd4a">More...</a><br /></td></tr>
<tr class="separator:a8f30c7752c68730b214f341f32e5dd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ad7bc4fb17dae24e50463d2a342d27"><td class="memItemLeft" align="right" valign="top">istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#aa9ad7bc4fb17dae24e50463d2a342d27">IlvSkipTo</a> (int character)</td></tr>
<tr class="memdesc:aa9ad7bc4fb17dae24e50463d2a342d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip to a given character in a stream.  <a href="#aa9ad7bc4fb17dae24e50463d2a342d27">More...</a><br /></td></tr>
<tr class="separator:aa9ad7bc4fb17dae24e50463d2a342d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8d7663b0749062080ec88ddf8670c6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a8c8d7663b0749062080ec88ddf8670c6">IlvSpc</a> ()</td></tr>
<tr class="memdesc:a8c8d7663b0749062080ec88ddf8670c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a 'space.'.  <a href="#a8c8d7663b0749062080ec88ddf8670c6">More...</a><br /></td></tr>
<tr class="separator:a8c8d7663b0749062080ec88ddf8670c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda1a3b1fbc881a24872d79557c1d99f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#aeda1a3b1fbc881a24872d79557c1d99f">IlvWriteString</a> (ostream &amp;stream, const char *string)</td></tr>
<tr class="memdesc:aeda1a3b1fbc881a24872d79557c1d99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a string to an output stream.  <a href="#aeda1a3b1fbc881a24872d79557c1d99f">More...</a><br /></td></tr>
<tr class="separator:aeda1a3b1fbc881a24872d79557c1d99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utility functions. </p>
<p><b>Library:</b> <tt>xviews</tt> or <tt>winviews</tt> or <tt>mviews</tt> (mutually exclusive)</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="af77645baba4325a69d90926e954a20b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af77645baba4325a69d90926e954a20b7">&sect;&nbsp;</a></span>IlvComputeArcBBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IlvComputeArcBBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIlvRect.html">IlvRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a47ead22a1022daec50724a367b02b842">IlFloat</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a47ead22a1022daec50724a367b02b842">IlFloat</a>&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIlvRect.html">IlvRect</a> &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the bounding box of a portion of an ellipse. </p>
<p>Use this global function to compute the bounding box of an arc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle that defines the size of the complete ellipse. </td></tr>
    <tr><td class="paramname">start</td><td>The start angle of the desired arc in degrees. </td></tr>
    <tr><td class="paramname">range</td><td>The angle range, in degrees, of the desired arc. </td></tr>
    <tr><td class="paramname">bbox</td><td>The return value of this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classIlvArc.html" title="Graphic class. ">IlvArc</a></code>. </dd></dl>

</div>
</div>
<a id="ae1543e5c5654cf6a999f68a7758f2666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1543e5c5654cf6a999f68a7758f2666">&sect;&nbsp;</a></span>IlvComputeArrow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IlvComputeArrow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a47ead22a1022daec50724a367b02b842">IlFloat</a>&#160;</td>
          <td class="paramname"><em>atpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIlvPoint.html">IlvPoint</a> *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Views_2include_8doc_2ilviews_2macros_8h.html#a6304764dd4460c4a474aa7843ac0e194">IlvDim</a>&#160;</td>
          <td class="paramname"><em>arrowBase</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Views_2include_8doc_2ilviews_2macros_8h.html#a6304764dd4460c4a474aa7843ac0e194">IlvDim</a>&#160;</td>
          <td class="paramname"><em>arrowLength</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the points that define an arrow on a segment. </p>
<p>Use this global function to compute the polygon points that define an arrow located on a line segment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The starting point of the line segment. </td></tr>
    <tr><td class="paramname">to</td><td>The ending point of the line segment. </td></tr>
    <tr><td class="paramname">atpos</td><td>The position of the arrow on the segment: <ul>
<li>
<code>0</code> = arrow head on the <code>from</code> point. </li>
<li>
<code>1</code> = arrow head on the <code>to</code> point. </li>
</ul>
</td></tr>
    <tr><td class="paramname">points</td><td>An array of at least three points that will be set to the computed coordinates that define the arrow. </td></tr>
    <tr><td class="paramname">arrowBase</td><td>Half the size of the arrow base. </td></tr>
    <tr><td class="paramname">arrowLength</td><td>The length of the arrow head. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classIlvArrowLine.html" title="Graphic class. ">IlvArrowLine</a></code>. </dd></dl>

</div>
</div>
<a id="a70d25ccfcfce2290ca453a2f33cbe0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d25ccfcfce2290ca453a2f33cbe0d3">&sect;&nbsp;</a></span>IlvCreateClosedSpline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IlvCreateClosedSpline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a1653965b0ba3aba43e2268d9825390ed">IlUInt</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIlvPoint.html">IlvPoint</a> *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a1653965b0ba3aba43e2268d9825390ed">IlUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>totalCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an array of points defining a closed B&eacute;zier spline. </p>
<p>This function creates the point arrays defining the edges of a closed shape that closely corresponds to the Bezier curve defined by the <em>count</em> points given in the <em>points</em> array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of control points stored in <em>points</em>. </td></tr>
    <tr><td class="paramname">points</td><td>The array of control points. </td></tr>
    <tr><td class="paramname">totalCount</td><td>Is set to the number of output definition points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of points that define the shape of the output spline. This array is allocated by an <code><a class="el" href="classIlPoolOf__OPENPAR__IlvPoint__CLOSEPAR__.html" title="A memory pool of arrays of IlvPoints. ">IlPoolOf(IlvPoint)</a></code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classIlvClosedSpline.html" title="Graphic class. ">IlvClosedSpline</a></code>, <code><a class="el" href="util_8h.html#ab42fcf58bed9a2a32b4558ef541bfc54" title="Creates an array of points defining an open Bézier spline. ">IlvCreateOpenSpline</a></code>, <code><a class="el" href="classIlvSpline.html" title="Graphic class. ">IlvSpline</a></code>. </dd></dl>

</div>
</div>
<a id="ab42fcf58bed9a2a32b4558ef541bfc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42fcf58bed9a2a32b4558ef541bfc54">&sect;&nbsp;</a></span>IlvCreateOpenSpline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IlvCreateOpenSpline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a1653965b0ba3aba43e2268d9825390ed">IlUInt</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIlvPoint.html">IlvPoint</a> *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a1653965b0ba3aba43e2268d9825390ed">IlUInt</a> &amp;&#160;</td>
          <td class="paramname"><em>totalCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an array of points defining an open B&eacute;zier spline. </p>
<p>This function creates the point arrays defining the edges of an open shape that closely corresponds to the Bezier curve defined by the <em>count</em> points given in the <em>points</em> array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of control points stored in <em>points</em>. </td></tr>
    <tr><td class="paramname">points</td><td>The array of control points. </td></tr>
    <tr><td class="paramname">totalCount</td><td>Is set to the number of output definition points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of points that define the shape of the output spline. This array is allocated by an <code><a class="el" href="classIlPoolOf__OPENPAR__IlvPoint__CLOSEPAR__.html" title="A memory pool of arrays of IlvPoints. ">IlPoolOf(IlvPoint)</a></code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classIlvClosedSpline.html" title="Graphic class. ">IlvClosedSpline</a></code>, <code><a class="el" href="util_8h.html#a70d25ccfcfce2290ca453a2f33cbe0d3" title="Creates an array of points defining a closed Bézier spline. ">IlvCreateClosedSpline</a></code>, <code><a class="el" href="classIlvSpline.html" title="Graphic class. ">IlvSpline</a></code>. </dd></dl>

</div>
</div>
<a id="ad3c634c63885d82f3b3407a99b60a55b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c634c63885d82f3b3407a99b60a55b">&sect;&nbsp;</a></span>IlvIntersectHorizontal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a> IlvIntersectHorizontal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a3bc8f2226932e099ef97a8474e9bbdcb">IlInt</a> *&#160;</td>
          <td class="paramname"><em>dir</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>IlTrue</code> if the horizontal line intercepts the segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>A point of the horizontal line. </td></tr>
    <tr><td class="paramname">from</td><td>First point of the segment. </td></tr>
    <tr><td class="paramname">to</td><td>Last point of the segment. </td></tr>
    <tr><td class="paramname">dir</td><td>Indicates how the horizontal line crosses the segment. If the returned value is <code>IlTrue</code> and <code>dir</code> is not <code>null</code>, this function will increment or decrement <code>*dir</code>, whether the segment crosses the horizontal ray from right-to-left (+1) or from left-to-right (-1). If the segment is included in the horizontal ray, <code>*dir</code> is not modified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IlTrue if the horizontal line intercepts the segment. </dd></dl>

</div>
</div>
<a id="afe0d4a4597646fd4d748da948e4ccb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe0d4a4597646fd4d748da948e4ccb76">&sect;&nbsp;</a></span>IlvLinesIntersect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a> IlvLinesIntersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>from1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>from2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIlvPoint.html">IlvPoint</a> *&#160;</td>
          <td class="paramname"><em>result</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>IlTrue</code> if there is an intersection point between two lines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from1</td><td>First point of the first line. </td></tr>
    <tr><td class="paramname">to1</td><td>Last point of the first line. </td></tr>
    <tr><td class="paramname">from2</td><td>First point of the second line. </td></tr>
    <tr><td class="paramname">to2</td><td>Last point of the second line. </td></tr>
    <tr><td class="paramname">result</td><td>Contains the coordinates of the intersection point if there is an intersection between the two lines. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IlTrue if there is an intersection point between the two lines. </dd></dl>

</div>
</div>
<a id="a3ef401e2a0f6a77b7a54ea9b195cf7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef401e2a0f6a77b7a54ea9b195cf7d6">&sect;&nbsp;</a></span>IlvPointInClosedSpline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a> IlvPointInClosedSpline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a1653965b0ba3aba43e2268d9825390ed">IlUInt</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIlvPoint.html">IlvPoint</a> *&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>IlTrue</code> if the point is in a closed spline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point. </td></tr>
    <tr><td class="paramname">count</td><td>Point count of the closed spline. </td></tr>
    <tr><td class="paramname">points</td><td>The points of the closed spline. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IlTrue if the point is in the closed spline. </dd></dl>

</div>
</div>
<a id="a0383645b3da710234e76cf5c04f06399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0383645b3da710234e76cf5c04f06399">&sect;&nbsp;</a></span>IlvPointInFilledSpline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a> IlvPointInFilledSpline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a1653965b0ba3aba43e2268d9825390ed">IlUInt</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIlvPoint.html">IlvPoint</a> *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a>&#160;</td>
          <td class="paramname"><em>windingRule</em> = <code><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a3e44d254cb5a7c404f4c9acb50135411">IlFalse</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>IlTrue</code> if the point is in a filled spline. </p>
<p>The algorithm of this function considers an infinite horizontal ray starting at the point and determines the intersections of this ray with the spline outline path. The results depend on the spline fill-rule: Odd-Even rule: the point is "in" if there is and odd number of intersections and "out" if it's an even number. Winding rule: the point is "in" if there is an unequal number of intersections from left to right and from right to left, as observed from the point. The point is "out" if these numbers are equal. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point. </td></tr>
    <tr><td class="paramname">count</td><td>Point count of the filled spline. </td></tr>
    <tr><td class="paramname">points</td><td>The points of the filled spline. </td></tr>
    <tr><td class="paramname">windingRule</td><td>If the value is <code>IlTrue</code>, the rule used is Winding, otherwise it is the Odd-Even rule. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IlTrue if the point is in the filled spline. </dd></dl>

</div>
</div>
<a id="a267f76ffd56641fe7688a4f5211e6fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267f76ffd56641fe7688a4f5211e6fae">&sect;&nbsp;</a></span>IlvPointInLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a> IlvPointInLine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>IlTrue</code> if the point is in a line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point. </td></tr>
    <tr><td class="paramname">from</td><td>First point of the line. </td></tr>
    <tr><td class="paramname">to</td><td>Last point of the line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IlTrue if the point is in the line. </dd></dl>

</div>
</div>
<a id="a98bcaebcbf50dc68e021321a7a7e96d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98bcaebcbf50dc68e021321a7a7e96d2">&sect;&nbsp;</a></span>IlvPointInPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a> IlvPointInPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a1653965b0ba3aba43e2268d9825390ed">IlUInt</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIlvPoint.html">IlvPoint</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a>&#160;</td>
          <td class="paramname"><em>windingRule</em> = <code><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a3e44d254cb5a7c404f4c9acb50135411">IlFalse</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>IlTrue</code> if the point is in a polygon. </p>
<p>The algorithm of this function considers an infinite horizontal ray starting at the point and determines the intersections of this ray with the polygon outline path. The results depend on the polygon fill-rule : Odd-Even rule: the point is "in" if there is and odd number of intersections and "out" if it's an even number. Winding rule: the point is "in" if there is an unequal number of intersections from left to right and from right to left, as observed from the point. The point is "out" if these numbers are equal. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point. </td></tr>
    <tr><td class="paramname">count</td><td>Point count of the polygon. </td></tr>
    <tr><td class="paramname">poly</td><td>The points of the polygon. </td></tr>
    <tr><td class="paramname">windingRule</td><td>If the value is <code>IlTrue</code>, the rule used is Winding, otherwise it is the Odd-Even rule. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IlTrue if the point is in the polygon. </dd></dl>

</div>
</div>
<a id="a834cfdc36f1ee08daee4bf173b74f5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834cfdc36f1ee08daee4bf173b74f5aa">&sect;&nbsp;</a></span>IlvPointInPolyline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a> IlvPointInPolyline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a1653965b0ba3aba43e2268d9825390ed">IlUInt</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIlvPoint.html">IlvPoint</a> *&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>IlTrue</code> if the point is in a polyline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point. </td></tr>
    <tr><td class="paramname">count</td><td>Point count of the polyline. </td></tr>
    <tr><td class="paramname">poly</td><td>The points of the polyline. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IlTrue if the point is in the polyline. </dd></dl>

</div>
</div>
<a id="a7b9535ee17f6299d78b5f8bbdd14967f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9535ee17f6299d78b5f8bbdd14967f">&sect;&nbsp;</a></span>IlvPointInSpline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a> IlvPointInSpline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIlvPoint.html">IlvPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a1653965b0ba3aba43e2268d9825390ed">IlUInt</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIlvPoint.html">IlvPoint</a> *&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>IlTrue</code> if the point is in a spline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point. </td></tr>
    <tr><td class="paramname">count</td><td>Point count of the spline. </td></tr>
    <tr><td class="paramname">points</td><td>The points of the spline. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IlTrue if the point is in the spline. </dd></dl>

</div>
</div>
<a id="a0bf1ac8ce1052e1db79a64284cc2d1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf1ac8ce1052e1db79a64284cc2d1ee">&sect;&nbsp;</a></span>IlvReadString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* IlvReadString </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string from an input stream. </p>
<p>Reads a complete description of a string from the input stream designated by <em>is</em> and returns a pointer to the read character array.<br />
 You can specify a buffer where the returned string is stored. It must be large enough to hold the incoming data.<br />
 When reading a string, <code>IlvReadString</code> expects an opening double quote character to start loading the data. It will convert C character escape sequences to regular characters, and will return when the closing double quote is reached. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The input stream. </td></tr>
    <tr><td class="paramname">buffer</td><td>If not <code>0</code>, this designates the buffer where the string is stored. If <em>buffer</em> is <code>0</code>, an internal buffer is allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>[code] When this function uses an internal buffer to store the returned string (<em>buffer</em> is <code>0</code>), this buffer may be overwritten by another call in the library. It uses an <code><a class="el" href="classIlPoolOf__OPENPAR__Char__CLOSEPAR__.html" title="A predefined memory pool that manages pointers to char. ">IlPoolOf(Char)</a></code>. If you need to keep this buffer, lock the data (see <code><a class="el" href="classIlPoolOf__OPENPAR__NAME__CLOSEPAR__.html" title="A generic class that handles memory pools. ">IlPoolOf(NAME)</a></code>) or copy this string before you call another function of Rogue Wave Views. You must never try to delete this array. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="util_8h.html#aeda1a3b1fbc881a24872d79557c1d99f" title="Writes a string to an output stream. ">IlvWriteString</a></code>, <code><a class="el" href="util_8h.html#a8f30c7752c68730b214f341f32e5dd4a" title="Skip spaces in a stream. ">IlvSkipSpaces</a></code>, <code><a class="el" href="util_8h.html#aa9ad7bc4fb17dae24e50463d2a342d27" title="Skip to a given character in a stream. ">IlvSkipTo</a></code>, <code>ostream::operator&gt;&gt;</code>. </dd></dl>

</div>
</div>
<a id="a8f30c7752c68730b214f341f32e5dd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f30c7752c68730b214f341f32e5dd4a">&sect;&nbsp;</a></span>IlvSkipSpaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">istream&amp; IlvSkipSpaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skip spaces in a stream. </p>
<p>This function actually is <em>manipulator</em> that is, a class that acts like a function in a stream context.<br />
 Use it to skip unwanted space characters when reading from istreams.<br />
 This function moves the current read pointer of the stream to the character located after any space character. A character is considered to be a space character if it has one of the ASCII codes: 32 (space), 10 (line feed), 13 (carriage return) or 7 (tab). The stream is in an <code>eof</code> state on return if the function cannot locate any space character in this input stream.<br />
 A common usage is to skip space areas before checking an incoming value: </p><div class="fragment"><div class="line">istream stream;</div><div class="line">...</div><div class="line">stream &lt;&lt; <a class="code" href="util_8h.html#a8f30c7752c68730b214f341f32e5dd4a">IlvSkipSpaces</a>();</div><div class="line"><span class="keywordflow">if</span> (stream.get() != <span class="charliteral">&#39;:&#39;</span>)</div><div class="line">    Error(ColonExpected);</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><code><a class="el" href="util_8h.html#a8c8d7663b0749062080ec88ddf8670c6" title="Gets a &#39;space.&#39;. ">IlvSpc</a></code>, <code><a class="el" href="util_8h.html#aa9ad7bc4fb17dae24e50463d2a342d27" title="Skip to a given character in a stream. ">IlvSkipTo</a></code>, <code><a class="el" href="util_8h.html#a0bf1ac8ce1052e1db79a64284cc2d1ee" title="Reads a string from an input stream. ">IlvReadString</a></code>. </dd></dl>

</div>
</div>
<a id="aa9ad7bc4fb17dae24e50463d2a342d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ad7bc4fb17dae24e50463d2a342d27">&sect;&nbsp;</a></span>IlvSkipTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">istream&amp; IlvSkipTo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>character</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skip to a given character in a stream. </p>
<p>This function actually is <em>manipulator</em> that is, a class that acts like a function in a stream context.<br />
 It moves the current read pointer of the stream to the character located just after the next character <em>character</em>. The stream is in <code>eof</code> state on return if the given character cannot be located in this input stream.<br />
 A common use is to skip the closing delimiter of a block descriptor: </p><div class="fragment"><div class="line">stream &gt;&gt; IlvSkipto(CloseDelimiter);</div><div class="line"><span class="keywordflow">if</span> (stream.eof())</div><div class="line">    Error(NoOpenDelimiter);</div><div class="line"><span class="comment">// read the delimited part</span></div><div class="line">stream &gt;&gt; IlvSkipto(CloseDelimiter);</div><div class="line"><span class="keywordflow">if</span> (stream.eof())</div><div class="line">    Error(NoCloseDelimiter);</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character after which to move the read pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c8d7663b0749062080ec88ddf8670c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8d7663b0749062080ec88ddf8670c6">&sect;&nbsp;</a></span>IlvSpc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* IlvSpc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a 'space.'. </p>
<p>This global function returns a static string that contains only a white space, followed by the ending <code>0</code>. This is used internally to save static data space.<br />
 A common usage is to output spaces in output streams: </p><div class="fragment"><div class="line">stream &lt;&lt; someValue &lt;&lt; <a class="code" href="util_8h.html#a8c8d7663b0749062080ec88ddf8670c6">IlvSpc</a>() &lt;&lt; someOtherValue;</div></div><!-- fragment --><p> You must not modify nor delete the returned string. </p><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="util_8h.html#aeda1a3b1fbc881a24872d79557c1d99f" title="Writes a string to an output stream. ">IlvWriteString</a></code>, <code><a class="el" href="util_8h.html#aa9ad7bc4fb17dae24e50463d2a342d27" title="Skip to a given character in a stream. ">IlvSkipTo</a></code>, <code><a class="el" href="util_8h.html#a8f30c7752c68730b214f341f32e5dd4a" title="Skip spaces in a stream. ">IlvSkipSpaces</a></code>. </dd></dl>

</div>
</div>
<a id="aeda1a3b1fbc881a24872d79557c1d99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeda1a3b1fbc881a24872d79557c1d99f">&sect;&nbsp;</a></span>IlvWriteString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IlvWriteString </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a string to an output stream. </p>
<p>This function writes a complete description of the <code>string</code> parameter into the indicated output stream. The output is made of an opening double quote character (<code>"</code>) followed by the string contents, where each special character is replaced by its <code>C</code> escape sequence. A closing double quote is added at the end of the output. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The output stream. </td></tr>
    <tr><td class="paramname">string</td><td>The string to be saved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="util_8h.html#a0bf1ac8ce1052e1db79a64284cc2d1ee" title="Reads a string from an input stream. ">IlvReadString</a></code>, <code><a class="el" href="util_8h.html#a8c8d7663b0749062080ec88ddf8670c6" title="Gets a &#39;space.&#39;. ">IlvSpc</a></code>, <code>ostream::operator&lt;&lt;</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<HR>
<P>&copy; Copyright 2017, Rogue Wave Software, Inc. All Rights Reserved.<br/>
Rogue Wave is a registered trademark of Rogue Wave Software, Inc. in the United States and other countries. All other trademarks are the property of their respective owners.</P>
</BODY>
</HTML>
