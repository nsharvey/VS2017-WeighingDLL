<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Rogue Wave Views Foundation Package: ilviews/base/smartptr.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="roguewave.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table border="0" cellpadding="4" cellspacing="0" width="100%">
  <tbody>
    <tr>
      <td id="projectlogo"><img alt="Rogue Wave logo" src="rwlogo.gif"/></td>
      <td id="projectname">Rogue Wave Views<br/>Foundation Package API Reference Guide</td>
      <td valign="middle"><font color="#003399"><center><b>Product Documentation:</b></font><br/><br/><b><a HREF="../../views.html" target="_top">Rogue Wave Views<br/>Documentation Home</a></b></center></td>
    </tr>
  </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_f1fed744a3af9d84a06b8e8ced3f1fdd.html">ilviews</a></li><li class="navelem"><a class="el" href="dir_4252820f9ee2fd5b0ee32db389e83bb3.html">base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">smartptr.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="Views_2include_8doc_2ilviews_2macros_8h.html">ilviews/macros.h</a>&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIlvSmartData.html">IlvSmartData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for reference counting.  <a href="classIlvSmartData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aeb0103b6c57d935f7c4973e91aed41a8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="smartptr_8h.html#aeb0103b6c57d935f7c4973e91aed41a8">IlvDerivedPointerClass</a>(SmartClass,  BaseSmartClass,  DataClass,  EXPORT)</td></tr>
<tr class="separator:aeb0103b6c57d935f7c4973e91aed41a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bfd42c5a141274a3446f87144d6e15"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="smartptr_8h.html#ab0bfd42c5a141274a3446f87144d6e15">IlvPointerClass</a>(SmartClass,  DataClass,  EXPORT)</td></tr>
<tr class="memdesc:ab0bfd42c5a141274a3446f87144d6e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for pointers that handle a reference counter for the objects they point to.  <a href="#ab0bfd42c5a141274a3446f87144d6e15">More...</a><br /></td></tr>
<tr class="separator:ab0bfd42c5a141274a3446f87144d6e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><b>Library:</b> <tt>views</tt><br/>Declaration of the reference counting management classes, <code><a class="el" href="classIlvSmartData.html" title="Base class for reference counting. ">IlvSmartData</a></code> and <code>IlvSmartPointer</code>, </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aeb0103b6c57d935f7c4973e91aed41a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0103b6c57d935f7c4973e91aed41a8">&sect;&nbsp;</a></span>IlvDerivedPointerClass</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IlvDerivedPointerClass</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">SmartClass, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BaseSmartClass, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">DataClass, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">EXPORT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This macro defines subclasses of <code>IlvSmartPointer</code> that point to subclasses of a base reference counting class. For example, if you define a subclass <code>MyDialogWindow: public MyWindow</code>, you must use the following macro to be able to use objects of type <code>pMyDialogWindow</code> in the same way as you would use a <code>MyDialogWindow*</code> object: <code> <a class="el" href="smartptr_8h.html#aeb0103b6c57d935f7c4973e91aed41a8">IlvDerivedPointerClass(pMyDialogWindow,pMyWindow,MyDialogWindow,MYPACKAGE)</a> </code> </p><dl class="section see"><dt>See also</dt><dd><code>IlvSmartPointer</code>. </dd></dl>

</div>
</div>
<a id="ab0bfd42c5a141274a3446f87144d6e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0bfd42c5a141274a3446f87144d6e15">&sect;&nbsp;</a></span>IlvPointerClass</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IlvPointerClass</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">SmartClass, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">DataClass, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">EXPORT&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base class for pointers that handle a reference counter for the objects they point to. </p>
<p>All the objects of the class <code><a class="el" href="classIlvSmartData.html" title="Base class for reference counting. ">IlvSmartData</a></code> that are allocated dynamically must be referenced by at least one <code>SmartPointer</code> object to be valid.</p>
<p>Smart pointers handle a reference counter for the objects they point to and destroy these objects when they are no longer visible. The use of smart pointers avoids memory leaks and greatly simplifies and secures memory management.</p>
<p>You handle a smart pointer <code>pA</code> to an object of class <code>A</code> exactly like an <code>A*</code> object. Some compilers are not able to analyze correctly the <code>pA::operator A*()</code>, thus requiring that you cast the smart pointer into a pointer explicitly.</p>
<p><em>Guidelines</em> </p><ul>
<li>
Regular pointers versus Smart Pointers<br />
 Assigning and deleting a smart pointer is fast, but slower than assigning and deleting a regular pointer. As a consequence, you should always make sure that you use the appropriate type of pointer. Here is a simple rule you can follow to determine which kind of pointer should be used in given situation: When a pointer has to be declared inside a pair of braces (<code>{}</code>), it should be a smart pointer. When it has to be declared inside a pair of parentheses (<code>()</code>), it should be a regular pointer.<br />
 Here is an example: <div class="fragment"><div class="line"><span class="keyword">class </span>MyWindow</div><div class="line">: <span class="keyword">public</span> <a class="code" href="classIlvSmartData.html">IlvSmartData</a> {</div><div class="line">    ...</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="smartptr_8h.html#ab0bfd42c5a141274a3446f87144d6e15">IlvPointerClass</a>(pMyWindow, MyWindow, MYPACKAGE); <span class="comment">// defines the class pMyWindow</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>MyDocument {</div><div class="line">    pMyWindow myWindow; <span class="comment">// A smart pointer, because we need the object </span></div><div class="line">                       <span class="comment">// to remain valid as long as the whole object</span></div><div class="line">                        <span class="comment">// is valid.</span></div><div class="line">    </div><div class="line">    <span class="keywordtype">void</span> setWindow(MyWindow* window) { </div><div class="line">            <span class="comment">// A regular pointer: </span></div><div class="line">            <span class="comment">// we don&#39;t need to change the reference count when</span></div><div class="line">            <span class="comment">// passing the object as an argument.</span></div><div class="line">         pMyWindow tmpW = window; <span class="comment">// A smart pointer: </span></div><div class="line">            <span class="comment">// we want the pointer to remain valid within</span></div><div class="line">            <span class="comment">// the method&#39;s scope.</span></div><div class="line">         <span class="keywordflow">for</span> (MyWindow* w = window; w != 0; w = w-&gt;next()) {</div><div class="line">             <span class="comment">// A regular pointer: w remains valid within this scope.</span></div><div class="line">             <span class="comment">// and we don&#39;t need to change the counters.</span></div><div class="line">         }</div><div class="line">         myWindow = window;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --> </li>
<li>
<p class="startli">Cycles<br />
 Reference counters maintained by smart pointers often generate reference cycles where objects reference each other in a circular way. The objects involved in reference cycles are never deleted because they are always pointed to by another object and, as a consequence, their reference counter is always positive. One solution to overcome this problem is to break the loop explicitly when you know that some objects will no longer be needed. A better solution, however, is to organize the data as a hierarchical structure that specifies which object is the parent and which object is the child. In a hierarchical structure, children should point to their parent via regular pointers instead of smart pointers.</p>
<p class="endli">In the above example, a pointer to <code>MyDocument</code> in <code>MyWindow</code> should be <code>MyDocument*</code> instead of <code>IlvSmartPointerTo&lt;MyDocument&gt;</code>. </p>
</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classIlvSmartData.html" title="Base class for reference counting. ">IlvSmartData</a></code>, <code><a class="el" href="smartptr_8h.html#aeb0103b6c57d935f7c4973e91aed41a8">IlvDerivedPointerClass</a></code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<HR>
<P>&copy; Copyright 2017, Rogue Wave Software, Inc. All Rights Reserved.<br/>
Rogue Wave is a registered trademark of Rogue Wave Software, Inc. in the United States and other countries. All other trademarks are the property of their respective owners.</P>
</BODY>
</HTML>
