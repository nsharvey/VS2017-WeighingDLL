<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Rogue Wave Views Foundation Package: IlvEventLoop Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="roguewave.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table border="0" cellpadding="4" cellspacing="0" width="100%">
  <tbody>
    <tr>
      <td id="projectlogo"><img alt="Rogue Wave logo" src="rwlogo.gif"/></td>
      <td id="projectname">Rogue Wave Views<br/>Foundation Package API Reference Guide</td>
      <td valign="middle"><font color="#003399"><center><b>Product Documentation:</b></font><br/><br/><b><a HREF="../../views.html" target="_top">Rogue Wave Views<br/>Documentation Home</a></b></center></td>
    </tr>
  </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classIlvEventLoop-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title"><tt>IlvEventLoop</tt> Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Event loop class.  
 <a href="classIlvEventLoop.html#details">More...</a></p>

<p><code>#include &lt;ilviews/base/evloop.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae61f14f963018116dca041e5d5e2f7ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIlvEventLoop.html#ae61f14f963018116dca041e5d5e2f7ad">IlvEventLoop</a> (<a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a> setIt=<a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a39035864463c97011d43ab465188d521">IlTrue</a>)</td></tr>
<tr class="memdesc:ae61f14f963018116dca041e5d5e2f7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ae61f14f963018116dca041e5d5e2f7ad">More...</a><br /></td></tr>
<tr class="separator:ae61f14f963018116dca041e5d5e2f7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa861389edd95c17f5635c35bd40d34"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="evloop_8h.html#a1935b90c90625eaddc3bb249a237598b">IlvIdleProcId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIlvEventLoop.html#abaa861389edd95c17f5635c35bd40d34">addIdleProc</a> (<a class="el" href="evloop_8h.html#a90691119ddb48358ea904560f4ad7d52">IlvIdleProc</a> idleProc, <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#ad9773aabbd330d9bc1156933e14d0240">IlAny</a> userArg)</td></tr>
<tr class="memdesc:abaa861389edd95c17f5635c35bd40d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an idle procedure.  <a href="#abaa861389edd95c17f5635c35bd40d34">More...</a><br /></td></tr>
<tr class="separator:abaa861389edd95c17f5635c35bd40d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531781ce61975bdc02776577e6d899c7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIlvEventLoop.html#a531781ce61975bdc02776577e6d899c7">addInput</a> (int fd, IlvLoopCallback cb, <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#ad9773aabbd330d9bc1156933e14d0240">IlAny</a> arg=0, IlvLoopCallback errorCb=0)</td></tr>
<tr class="memdesc:a531781ce61975bdc02776577e6d899c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an external source of input.  <a href="#a531781ce61975bdc02776577e6d899c7">More...</a><br /></td></tr>
<tr class="separator:a531781ce61975bdc02776577e6d899c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea04e3df68958162182e23ff891ef17"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIlvEventLoop.html#acea04e3df68958162182e23ff891ef17">addOutput</a> (int fd, IlvLoopCallback cb, <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#ad9773aabbd330d9bc1156933e14d0240">IlAny</a> arg=0, IlvLoopCallback errorCb=0)</td></tr>
<tr class="memdesc:acea04e3df68958162182e23ff891ef17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an external source of input.  <a href="#acea04e3df68958162182e23ff891ef17">More...</a><br /></td></tr>
<tr class="separator:acea04e3df68958162182e23ff891ef17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d96bfbd41e2c7605446b64b3c5de824"><td class="memItemLeft" align="right" valign="top">virtual IlvRedrawProcLink *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIlvEventLoop.html#a5d96bfbd41e2c7605446b64b3c5de824">addRedrawProc</a> (<a class="el" href="evloop_8h.html#a90691119ddb48358ea904560f4ad7d52">IlvIdleProc</a> redrawProc, <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#ad9773aabbd330d9bc1156933e14d0240">IlAny</a> userArg)</td></tr>
<tr class="memdesc:a5d96bfbd41e2c7605446b64b3c5de824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a redraw procedure.  <a href="#a5d96bfbd41e2c7605446b64b3c5de824">More...</a><br /></td></tr>
<tr class="separator:a5d96bfbd41e2c7605446b64b3c5de824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab156a6495854eca6b4e2606bacaef9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIlvEventLoop.html#a5ab156a6495854eca6b4e2606bacaef9">dispatchEvent</a> (<a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#ad9773aabbd330d9bc1156933e14d0240">IlAny</a> systemEvent)</td></tr>
<tr class="memdesc:a5ab156a6495854eca6b4e2606bacaef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches an event.  <a href="#a5ab156a6495854eca6b4e2606bacaef9">More...</a><br /></td></tr>
<tr class="separator:a5ab156a6495854eca6b4e2606bacaef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad7523bc99275e5451e869f3d3a6abb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIlvEventLoop.html#a8ad7523bc99275e5451e869f3d3a6abb">flushRedraw</a> (<a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a1653965b0ba3aba43e2268d9825390ed">IlUInt</a> level=0)</td></tr>
<tr class="memdesc:a8ad7523bc99275e5451e869f3d3a6abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes any pending redraw requests.  <a href="#a8ad7523bc99275e5451e869f3d3a6abb">More...</a><br /></td></tr>
<tr class="separator:a8ad7523bc99275e5451e869f3d3a6abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af067549b3f16ee35ae786dd82b1ab82e"><td class="memItemLeft" align="right" valign="top"><a id="af067549b3f16ee35ae786dd82b1ab82e"></a>
<a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a1653965b0ba3aba43e2268d9825390ed">IlUInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIlvEventLoop.html#af067549b3f16ee35ae786dd82b1ab82e">lazyRedrawLevel</a> () const</td></tr>
<tr class="memdesc:af067549b3f16ee35ae786dd82b1ab82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">See below. <br /></td></tr>
<tr class="separator:af067549b3f16ee35ae786dd82b1ab82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263302c0589ec0cd77825ba2037a9411"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#ad9773aabbd330d9bc1156933e14d0240">IlAny</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIlvEventLoop.html#a263302c0589ec0cd77825ba2037a9411">nextEvent</a> (<a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#ad9773aabbd330d9bc1156933e14d0240">IlAny</a> systemEvent)</td></tr>
<tr class="memdesc:a263302c0589ec0cd77825ba2037a9411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets next event from the windowing system.  <a href="#a263302c0589ec0cd77825ba2037a9411">More...</a><br /></td></tr>
<tr class="separator:a263302c0589ec0cd77825ba2037a9411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad467bd1743505d7e1f2d54c78351344c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="evloop_8h.html#a3f73d412e7a837d6785a87de072141b3">IlvInputMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIlvEventLoop.html#ad467bd1743505d7e1f2d54c78351344c">pendingInput</a> ()</td></tr>
<tr class="memdesc:ad467bd1743505d7e1f2d54c78351344c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates pending input sources.  <a href="#ad467bd1743505d7e1f2d54c78351344c">More...</a><br /></td></tr>
<tr class="separator:ad467bd1743505d7e1f2d54c78351344c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2eb27ff81a190f65da11cc292313cf6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="evloop_8h.html#a3f73d412e7a837d6785a87de072141b3">IlvInputMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIlvEventLoop.html#ac2eb27ff81a190f65da11cc292313cf6">processInput</a> (<a class="el" href="evloop_8h.html#a3f73d412e7a837d6785a87de072141b3">IlvInputMask</a> inputMask)</td></tr>
<tr class="memdesc:ac2eb27ff81a190f65da11cc292313cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process input from the selected source.  <a href="#ac2eb27ff81a190f65da11cc292313cf6">More...</a><br /></td></tr>
<tr class="separator:ac2eb27ff81a190f65da11cc292313cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e68deca8c5bd13fd1c1a0d69a3c0af5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIlvEventLoop.html#a2e68deca8c5bd13fd1c1a0d69a3c0af5">removeIdleProc</a> (<a class="el" href="evloop_8h.html#a1935b90c90625eaddc3bb249a237598b">IlvIdleProcId</a> idleProcId)</td></tr>
<tr class="memdesc:a2e68deca8c5bd13fd1c1a0d69a3c0af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an idle procedure from the event loop.  <a href="#a2e68deca8c5bd13fd1c1a0d69a3c0af5">More...</a><br /></td></tr>
<tr class="separator:a2e68deca8c5bd13fd1c1a0d69a3c0af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458928ffdf6524e8f247de1b885759a1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIlvEventLoop.html#a458928ffdf6524e8f247de1b885759a1">removeInput</a> (int fd)</td></tr>
<tr class="memdesc:a458928ffdf6524e8f247de1b885759a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an external source of input.  <a href="#a458928ffdf6524e8f247de1b885759a1">More...</a><br /></td></tr>
<tr class="separator:a458928ffdf6524e8f247de1b885759a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be6ce3ed42a4bbee22b5e44b9f7b14d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIlvEventLoop.html#a0be6ce3ed42a4bbee22b5e44b9f7b14d">removeOutput</a> (int fd)</td></tr>
<tr class="memdesc:a0be6ce3ed42a4bbee22b5e44b9f7b14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an external source of input.  <a href="#a0be6ce3ed42a4bbee22b5e44b9f7b14d">More...</a><br /></td></tr>
<tr class="separator:a0be6ce3ed42a4bbee22b5e44b9f7b14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab233ebea71777e182563f64850538acb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIlvEventLoop.html#ab233ebea71777e182563f64850538acb">removeRedrawProc</a> (IlvRedrawProcLink *procId)</td></tr>
<tr class="memdesc:ab233ebea71777e182563f64850538acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a redraw procedure from the queue.  <a href="#ab233ebea71777e182563f64850538acb">More...</a><br /></td></tr>
<tr class="separator:ab233ebea71777e182563f64850538acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51bcfdd2953bfcbed627ab3c18d2577"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIlvEventLoop.html#ad51bcfdd2953bfcbed627ab3c18d2577">setLazyRedraw</a> (<a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a1653965b0ba3aba43e2268d9825390ed">IlUInt</a> lazy)</td></tr>
<tr class="memdesc:ad51bcfdd2953bfcbed627ab3c18d2577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get/Set the lazy redraw mechanism.  <a href="#ad51bcfdd2953bfcbed627ab3c18d2577">More...</a><br /></td></tr>
<tr class="separator:ad51bcfdd2953bfcbed627ab3c18d2577"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa8614da6884baa985688946a6c38cb3d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classIlvEventLoop.html">IlvEventLoop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIlvEventLoop.html#aa8614da6884baa985688946a6c38cb3d">getEventLoop</a> ()</td></tr>
<tr class="memdesc:aa8614da6884baa985688946a6c38cb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current event loop.  <a href="#aa8614da6884baa985688946a6c38cb3d">More...</a><br /></td></tr>
<tr class="separator:aa8614da6884baa985688946a6c38cb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d8ca6602c286995ac46539cd79c80f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIlvEventLoop.html#ac9d8ca6602c286995ac46539cd79c80f">setEventLoop</a> (<a class="el" href="classIlvEventLoop.html">IlvEventLoop</a> *eventLoop)</td></tr>
<tr class="memdesc:ac9d8ca6602c286995ac46539cd79c80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current event loop.  <a href="#ac9d8ca6602c286995ac46539cd79c80f">More...</a><br /></td></tr>
<tr class="separator:ac9d8ca6602c286995ac46539cd79c80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Event loop class. </p>
<p><b>Library:</b> <tt>xviews</tt> or <tt>winviews</tt> or <tt>mviews</tt> (mutually exclusive)</p>
<p>This class handles the processing of inputs and events. Rogue Wave Views creates a global instance of this class that the application can access using the <code>getEventLoop</code> static method. The application can define its own event-processing mechanism by subclassing <code><a class="el" href="classIlvEventLoop.html" title="Event loop class. ">IlvEventLoop</a></code> and overriding the <code>nextEvent</code> and/or <code>dispatchEvent</code> member functions. See the description of <code>setEventLoop</code> for important warnings about the use of subclasses. </p><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classIlvDisplay.html#a7afec2d14e5f7f29febf288235c62750" title="Reads and dispatches all pending events. ">IlvDisplay::readAndDispatchEvents</a></code>, <code><a class="el" href="classIlvDisplay.html#a2f7b6b6069aae5a057cc4e8e46dee6ee" title="Reads and dispatches the next event. ">IlvDisplay::waitAndDispatchEvents</a></code>, <code><a class="el" href="evloop_8h.html#a8133b39058165d53401be758cf63474f" title="Starts the event loop. ">IlvMainLoop</a></code>, <code><a class="el" href="classIlvTimer.html" title="Timer class. ">IlvTimer</a></code>. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae61f14f963018116dca041e5d5e2f7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61f14f963018116dca041e5d5e2f7ad">&sect;&nbsp;</a></span>IlvEventLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IlvEventLoop::IlvEventLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a>&#160;</td>
          <td class="paramname"><em>setIt</em> = <code><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a39035864463c97011d43ab465188d521">IlTrue</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Initializes an instance of event loop. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setIt</td><td>If it is set to <code>IlTrue</code>, the new instance is set as the current event loop by a call to the static member function <code>setEventLoop</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abaa861389edd95c17f5635c35bd40d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa861389edd95c17f5635c35bd40d34">&sect;&nbsp;</a></span>addIdleProc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="evloop_8h.html#a1935b90c90625eaddc3bb249a237598b">IlvIdleProcId</a> IlvEventLoop::addIdleProc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="evloop_8h.html#a90691119ddb48358ea904560f4ad7d52">IlvIdleProc</a>&#160;</td>
          <td class="paramname"><em>idleProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#ad9773aabbd330d9bc1156933e14d0240">IlAny</a>&#160;</td>
          <td class="paramname"><em>userArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an idle procedure. </p>
<p>An idle procedure is a function provided by the user that is automatically called by the event loop when there is nothing else to do (no events, no timers or external inputs to process).<br />
 Idle procedures must be written in such a way that they do not alter the interactive responsiveness of the application. They should return quickly enough not to block the event loop, in case some input has arrived.<br />
 Idle procedures are handled as Last-In First-Out stack. Only the element at the top of the stack is used by the event loop. New idle procedures are put at the top of the stack. When an idle procedure must be called, the event loop does the following:<br />
 </p><ol>
<li>
It removes the top-most idle procedure from the stack. </li>
<li>
It calls the idle procedure. </li>
<li>
It puts it back at the top of the stack if the idle procedure returns <code>IlFalse</code>. </li>
</ol>
<p>This mechanism shows that an idle procedure can be considered as removed when it returns <code>IlTrue</code>. It also shows that if an idle procedure A adds an idle procedure B and returns <code>IlTrue</code>, A will get priority over B because A is automatically added to the stack right after B.<br />
 The <code>addIldleProc</code> member function adds an idle procedure to the event loop and returns an ID that can be used by the application to explicitly remove the idle procedure by calling the <code>removeIdleProc</code> member function.<br />
 An idle procedure that has a lengthy process to perform should split the work into several small pieces. Typically, the user argument <code>userArg</code> could point to some data used to store the status of a long computation. The status can then be retrieved the next time the idle procedure is called. </p><dl class="section return"><dt>Returns</dt><dd>The ID number used to identify the idle procedure entry. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idleProc</td><td>The idle procedure. </td></tr>
    <tr><td class="paramname">userArg</td><td>The argument to use when calling the idle procedure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a531781ce61975bdc02776577e6d899c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531781ce61975bdc02776577e6d899c7">&sect;&nbsp;</a></span>addInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IlvEventLoop::addInput </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IlvLoopCallback&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#ad9773aabbd330d9bc1156933e14d0240">IlAny</a>&#160;</td>
          <td class="paramname"><em>arg</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IlvLoopCallback&#160;</td>
          <td class="paramname"><em>errorCb</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an external source of input. </p>
<p>This member function is available only on Unix platforms. It is used to add Unix file descriptors as new input sources for the application. The <em>fd</em> argument must be of a file descriptor type supported by the <code>select</code> function used internally by the event loop.<br />
 The user input callback <em>cb</em> is triggered if the <code>select</code> function determines that <em>fd</em> is ready to be read, i.e. that a read will not block. The user error callback <em>errorCb</em> is triggered when an error occurs in the <code>select</code> function.<br />
 The user callbacks <em>cb</em> and <em>errorCb</em> are called with <em>fd</em> and <em>arg</em> as parameters.<br />
 The function call:<br />
 <code>IlvRegisterInput(fd, cb, arg, errorCb);</code><br />
 is identical to:<br />
 <code><a class="el" href="classIlvEventLoop.html#aa8614da6884baa985688946a6c38cb3d" title="Gets the current event loop. ">IlvEventLoop::getEventLoop()</a>-&gt;addInput(fd, cb, arg, errorCb)</code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>File descriptor of a type supported by <code>select</code>. </td></tr>
    <tr><td class="paramname">cb</td><td>The user callback to call when <em>fd</em> is ready for reading. </td></tr>
    <tr><td class="paramname">arg</td><td>The user argument to pass to <em>cb</em> or <em>errorCb</em>. </td></tr>
    <tr><td class="paramname">errorCb</td><td>The user callback to call when an error is detected on the file descriptor <em>fd</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code>IlvRegisterInput</code>. </dd></dl>

</div>
</div>
<a id="acea04e3df68958162182e23ff891ef17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea04e3df68958162182e23ff891ef17">&sect;&nbsp;</a></span>addOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IlvEventLoop::addOutput </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IlvLoopCallback&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#ad9773aabbd330d9bc1156933e14d0240">IlAny</a>&#160;</td>
          <td class="paramname"><em>arg</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IlvLoopCallback&#160;</td>
          <td class="paramname"><em>errorCb</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an external source of input. </p>
<p>This member function is available only on Unix platforms. Very similar to the member function <code>addInput</code>, this function is used to add to the event loop Unix file descriptors to watch. The <em>fd</em> argument must be of a file descriptor type supported by the <code>select</code> function used internally by the event loop.<br />
 The user callback <em>cb</em> is triggered if the <code>select</code> function determines that <em>fd</em> is ready for writing. The user error callback <em>errorCb</em> is triggered when an error occurs in the <code>select</code> function.<br />
 The user callbacks <em>cb</em> and <em>errorCb</em> are called with <em>fd</em> and <em>arg</em> as parameters.<br />
 The function call:<br />
 <code>IlvRegisterOutput(fd, cb, arg, errorCb);</code><br />
 is identical to:<br />
 <code><a class="el" href="classIlvEventLoop.html#aa8614da6884baa985688946a6c38cb3d" title="Gets the current event loop. ">IlvEventLoop::getEventLoop()</a>-&gt;addOutput(fd, cb, arg, errorCb)</code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>File descriptor of a type supported by <code>select</code>. </td></tr>
    <tr><td class="paramname">cb</td><td>The user callback to call when <em>fd</em> is ready for writing. </td></tr>
    <tr><td class="paramname">arg</td><td>The user argument to pass to <em>cb</em> or <em>errorCb</em>. </td></tr>
    <tr><td class="paramname">errorCb</td><td>The user callback to call when an error is detected on the file descriptor <em>fd</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code>IlvRegisterOutput</code>. </dd></dl>

</div>
</div>
<a id="a5d96bfbd41e2c7605446b64b3c5de824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d96bfbd41e2c7605446b64b3c5de824">&sect;&nbsp;</a></span>addRedrawProc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual IlvRedrawProcLink* IlvEventLoop::addRedrawProc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="evloop_8h.html#a90691119ddb48358ea904560f4ad7d52">IlvIdleProc</a>&#160;</td>
          <td class="paramname"><em>redrawProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#ad9773aabbd330d9bc1156933e14d0240">IlAny</a>&#160;</td>
          <td class="paramname"><em>userArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a redraw procedure. </p>
<p>Redraw procedures are like idle procedures, but they are executed with a higher priority level, every time some input has been handled by the main loop. They are mainly used to handle asynchronous redraws generated by <code><a class="el" href="classIlvContainer.html#a9d74073c1126ff5cbf44378f8a1e4bd7" title="Invalidates an object&#39;s region. ">IlvContainer::invalidateRegion()</a></code> and <code>IlvManager::invalidateRegion()</code>. </p>

</div>
</div>
<a id="a5ab156a6495854eca6b4e2606bacaef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab156a6495854eca6b4e2606bacaef9">&sect;&nbsp;</a></span>dispatchEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a> IlvEventLoop::dispatchEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#ad9773aabbd330d9bc1156933e14d0240">IlAny</a>&#160;</td>
          <td class="paramname"><em>systemEvent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatches an event. </p>
<p>Dispatches an event to its destination view. When redefining this member function, you should not call the function <code>IlvDispatchEvent</code>, to avoid endless recursion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">systemEvent</td><td>Pointer to a system-dependant event type; it is equivalent to <code>XEvent*</code> on Unix/X11 platforms and to <code>MSG*</code> on Windows platforms. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ad7523bc99275e5451e869f3d3a6abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad7523bc99275e5451e869f3d3a6abb">&sect;&nbsp;</a></span>flushRedraw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IlvEventLoop::flushRedraw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a1653965b0ba3aba43e2268d9825390ed">IlUInt</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes any pending redraw requests. </p>
<p>This method sequentially removes all redraw requests from the queue and executes their attached callback. </p>

</div>
</div>
<a id="aa8614da6884baa985688946a6c38cb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8614da6884baa985688946a6c38cb3d">&sect;&nbsp;</a></span>getEventLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classIlvEventLoop.html">IlvEventLoop</a>* IlvEventLoop::getEventLoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current event loop. </p>
<dl class="section return"><dt>Returns</dt><dd>The instance of <code><a class="el" href="classIlvEventLoop.html" title="Event loop class. ">IlvEventLoop</a></code> currently being used. </dd></dl>

</div>
</div>
<a id="a263302c0589ec0cd77825ba2037a9411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263302c0589ec0cd77825ba2037a9411">&sect;&nbsp;</a></span>nextEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#ad9773aabbd330d9bc1156933e14d0240">IlAny</a> IlvEventLoop::nextEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#ad9773aabbd330d9bc1156933e14d0240">IlAny</a>&#160;</td>
          <td class="paramname"><em>systemEvent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets next event from the windowing system. </p>
<p>Gets the next system-dependant event that must be treated. The function also handles timers and external event sources (when applicable) internally managed. If no event is available, the function waits until a new event is sent by the system. When redefining this method, the function <code>IlvNextEvent</code> must not be called, to avoid endless recursion. In the Motif version, this method is equivalent to <code>XtAppNextEvent</code>. </p><dl class="section return"><dt>Returns</dt><dd>On Unix/X11 platforms, the returned value is a pointer to the <code><a class="el" href="classIlvDisplay.html" title="Display class. ">IlvDisplay</a></code> instance associated with the X Display that generated this event. On Windows platforms, the returned value is <code>0</code> if the event is the <code>WM_QUIT</code> message and non-<code>0</code> value otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">systemEvent</td><td>Pointer to a system-dependant event type; it is equivalent to <code>XEvent*</code> on Unix/X11 platforms and to <code>MSG*</code> on Windows platforms. The parameter is used to return the next event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad467bd1743505d7e1f2d54c78351344c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad467bd1743505d7e1f2d54c78351344c">&sect;&nbsp;</a></span>pendingInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="evloop_8h.html#a3f73d412e7a837d6785a87de072141b3">IlvInputMask</a> IlvEventLoop::pendingInput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates pending input sources. </p>
<p>Queries the event loop about pending input sources, that is, events, timers, and external inputs. On Unix platforms, external input sources are added by the <code>addInput</code> or <code>addOutput</code> member functions. On Microsoft Windows platforms, Rogue Wave Views considers user messages (that is, messages with a value greater than <code>WM_USER</code>) as external input sources. </p><dl class="section return"><dt>Returns</dt><dd>One of the following values:<br />
 <ul>
<li>
<code>IlvInputNone:</code> no input pending </li>
<li>
<code>IlvInputAll:</code> all types of input are pending </li>
</ul>
or an <code>OR</code> combination of:<br />
 <ul>
<li>
<code>IlvInputEvent:</code> events are pending </li>
<li>
<code>IlvInputTimer:</code> timers are pending </li>
<li>
<code>IlvInputExternal:</code> external inputs are pending </li>
</ul>
Note that <code>IlvInputAll</code> is equal to: <code>(IlvInputEvent | IlvInputTimer | IlvInputExternal)</code> </dd></dl>

</div>
</div>
<a id="ac2eb27ff81a190f65da11cc292313cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2eb27ff81a190f65da11cc292313cf6">&sect;&nbsp;</a></span>processInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="evloop_8h.html#a3f73d412e7a837d6785a87de072141b3">IlvInputMask</a> IlvEventLoop::processInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="evloop_8h.html#a3f73d412e7a837d6785a87de072141b3">IlvInputMask</a>&#160;</td>
          <td class="paramname"><em>inputMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process input from the selected source. </p>
<p>Processes one piece of input from the input sources specified by <em>inputMask</em>. Only one event, or one timer, or one external source of input is processed. Events are processed by calling <code>IlvDispatchEvent</code>. If there is no input on any of the specified sources, the function blocks until input is available. Specifying <code>IlvInputNone</code> as parameter makes little sense and may block the application permanently.<br />
 There are limitations on this method:<br />
 </p><ul>
<li>
On Unix platforms, when using the libmviews library (as opposed to libxviews), the <code>processInput</code> member function does not return the type of input processed (since this information is not provided by Xt). </li>
<li>
On Windows platforms, not all combinations of <code>IlvInputMask</code> are supported. The supported values are the following:<br />
 <ul>
<li>
<code>IlvInputEvent | IlvInputTimer</code> </li>
<li>
<code>IlvInputTimer</code> </li>
<li>
<code>IlvInputExternal</code> </li>
<li>
<code>IlvInputAll</code> </li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The one (and only one) type of input the function has processed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputMask</td><td>An <code>OR</code> combination of <code>IlvInputEvent</code>, <code>IlvInputTimer</code>, and <code>IlvInputExternal</code> specifying the sources of input to process. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e68deca8c5bd13fd1c1a0d69a3c0af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e68deca8c5bd13fd1c1a0d69a3c0af5">&sect;&nbsp;</a></span>removeIdleProc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a> IlvEventLoop::removeIdleProc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="evloop_8h.html#a1935b90c90625eaddc3bb249a237598b">IlvIdleProcId</a>&#160;</td>
          <td class="paramname"><em>idleProcId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an idle procedure from the event loop. </p>
<dl class="section return"><dt>Returns</dt><dd><code>IlFalse</code> if the idle procedure could not be found. Otherwise, <code>IlTrue</code> is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idleProcId</td><td>The ID number identifying the idle procedure for the event loop. This value was returned by <code>addIdeProc</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a458928ffdf6524e8f247de1b885759a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a458928ffdf6524e8f247de1b885759a1">&sect;&nbsp;</a></span>removeInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IlvEventLoop::removeInput </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an external source of input. </p>
<p>This member function is available only on Unix platforms. It is used to remove a file descriptor registered by <code>addInput</code> to be monitored by the event loop as a source of input. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The file descriptor to remove as source of input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code>IlvUnRegisterInput</code>. </dd></dl>

</div>
</div>
<a id="a0be6ce3ed42a4bbee22b5e44b9f7b14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be6ce3ed42a4bbee22b5e44b9f7b14d">&sect;&nbsp;</a></span>removeOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IlvEventLoop::removeOutput </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an external source of input. </p>
<p>This member function is available only on Unix platforms. It is used to remove a file descriptor registered by <code>addOutput</code> to be monitored by the event loop. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The file descriptor to remove from the event loop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code>IlvUnRegisterOuput</code>. </dd></dl>

</div>
</div>
<a id="ab233ebea71777e182563f64850538acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab233ebea71777e182563f64850538acb">&sect;&nbsp;</a></span>removeRedrawProc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a377df7981ad27a8acbcbef16617450ea">IlBoolean</a> IlvEventLoop::removeRedrawProc </td>
          <td>(</td>
          <td class="paramtype">IlvRedrawProcLink *&#160;</td>
          <td class="paramname"><em>procId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a redraw procedure from the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procId</td><td>A pointer to the redraw procedure that must be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>IlTrue</code> if the removal was successful, or <code>IlFalse</code> otherwise. </dd></dl>

</div>
</div>
<a id="ac9d8ca6602c286995ac46539cd79c80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d8ca6602c286995ac46539cd79c80f">&sect;&nbsp;</a></span>setEventLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void IlvEventLoop::setEventLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIlvEventLoop.html">IlvEventLoop</a> *&#160;</td>
          <td class="paramname"><em>eventLoop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the current event loop. </p>
<p>Sets <em>eventLoop</em> as the current event loop. The previous event loop is not deleted. This static member function allows the application to use its own subclass of <code><a class="el" href="classIlvEventLoop.html" title="Event loop class. ">IlvEventLoop</a></code>. The most common use of this function is to set the customized event loop once and for all at application start-up. You can also temporarily set a local event loop for a specific task and reset the previous one once the task is completed. Any other use is highly discouraged. In particular, the current event loop should be the same before and after the dispatching of an event. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventLoop</td><td>The event loop to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad51bcfdd2953bfcbed627ab3c18d2577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad51bcfdd2953bfcbed627ab3c18d2577">&sect;&nbsp;</a></span>setLazyRedraw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IlvEventLoop::setLazyRedraw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="IFC_2include_8doc_2ilog_2macros_8h.html#a1653965b0ba3aba43e2268d9825390ed">IlUInt</a>&#160;</td>
          <td class="paramname"><em>lazy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get/Set the lazy redraw mechanism. </p>
<p>When invalidating regions (calling <code>invalidateRegion()</code>), containers and managers schedule by default a redraw procedure that will defer redraws until no more object management needs to be done. This greatly improves the overall performance and responsiveness of the user interface. However, for compatibility reasons, or to implement special deferred draw mechanisms, you may wish to turn off this mechanism and perform redraw tasks only explicitly.</p>
<p>Call <code>setLazyRedraw(0)</code> to turn off the scheduling of redraw tasks when invalidating regions. Call <code>setLazyRedraw(1)</code> to turn the default lazy redraw mechanism back on. In this case, calls to <code>initReDraw/<code>reDrawViews</code> will</code> preempt the lazy redraw mechanism to maintain compatibility with former deferred redraw mechanisms. This means that calls to <code>invalidateRegion</code> inside a pair of <code>initReDraw/<code>reDrawViews</code> will</code> not schedule a redraw task, and that the most external <code>reDrawViews</code> will force a redrawing of the invalidated regions. However, if you never call <code>initReDraw</code> or <code>reDrawViews</code> in this mode, you will benefit from the lazy redraw mechanism, which schedules drawing tasks more efficiently. Call <code>setLazyRedraw(2)</code> to benefit from the full optimizations and code simplifications that the lazy redraw mechanism allows. At this level, calls to <code>initReDraw/<code>reDrawViews</code> will</code> not have any effect, allowing all existing programs to benefit from the full lazy redraw mechanism. However, some incompatibilities may appear in this mode when interleaving direct drawing (like when drawing in Xor mode) and deferred drawing, which is why this mode is not the default. Later versions of Views may however set the default value of the lazy redraw level to <code>2</code>.</p>
<p>The environment variable <code>ILV_LAZY_REDRAW</code> can be used to control the lazy redraw mode externally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lazy</td><td>Integer value indicating the type of lazy redraw mechanism to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<HR>
<P>&copy; Copyright 2017, Rogue Wave Software, Inc. All Rights Reserved.<br/>
Rogue Wave is a registered trademark of Rogue Wave Software, Inc. in the United States and other countries. All other trademarks are the property of their respective owners.</P>
</BODY>
</HTML>
