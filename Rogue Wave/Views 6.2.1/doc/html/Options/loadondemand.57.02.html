<!DOCTYPE html ><html xml:lang="en" lang="en" data-highlight-require-whitespace="false" xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><!-- RW Customization - favicon file --><link rel="shortcut icon" href="connect/favicon.ico" /><title>How Load-on-Demand Works</title><link rel="Prev" href="loadondemand.57.01.html" title="Previous" /><link rel="Next" href="loadondemand.57.03.html" title="Next" /><link rel="StyleSheet" href="css/loadondemand.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/skin.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/social.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/webworks.css" type="text/css" media="all" /><!--[if IE 7]><link rel="StyleSheet" href="css/loadondemand_IE7.css" type="text/css" media="all" /><![endif]--><link rel="StyleSheet" href="css/custom.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/print.css" type="text/css" media="print" /><script type="text/javascript">
    'use strict';

    var redirect_url, page_hash;

    if ((window === window.top) && (window.navigator.userAgent.indexOf('bot/') === -1)) {
        // Redirect
        //
        redirect_url = "../views.html#page/Options/loadondemand.57.02.html";
        if (window.document.location.hash.length > 1) {
            // Sanitize and append it
            //
            page_hash = window.document.location.hash.substring(1);
            page_hash = page_hash.replace(/[\\><:;"]|%5C|%3C|%3E|%3A|%3B|%22/gi, '');
            redirect_url += '#' + page_hash;
        }
        window.document.location.replace(redirect_url);
    }
</script><script type="text/javascript" src="scripts/common.js"></script><script type="text/javascript" src="scripts/page.js"></script><script type="text/javascript" src="scripts/search-client.js"></script><script type="text/javascript" src="scripts/unidata.js"></script><script type="text/javascript" src="scripts/unibreak.js"></script><script type="text/javascript">var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-111257570-3']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script></head><body id="pN8AvRWndGUO6AGWZVJicDHg" class="ww_skin_page_body" onload="Page.OnLoad('../views.html#page/Options/loadondemand.57.02.html');"><header id="wwconnect_header"><div class="ww_skin_breadcrumbs"><span class="ww_skin_breadcrumbs_parent"><a href="../Options/docfrontcover.html#wwconnect_header">Maps</a></span><span class="ww_skin_breadcrumbs_divider"> &gt; </span><span class="ww_skin_breadcrumbs_parent"><a href="../Options/loadondemand.57.01.html#wwconnect_header">Using Load-On-Demand</a></span><span class="ww_skin_breadcrumbs_divider"> &gt; </span><span class="ww_skin_breadcrumbs_current">How Load-on-Demand Works</span></div><div class="ww_skin_page_toolbar"><a class="ww_behavior_print ww_skin ww_skin_print" title="Print" href="#">&nbsp;</a></div></header><div id="ww998326" class="Heading1"><span></span>How Load-on-Demand Works</div><div id="ww998327" class="Body">With the load-on-demand mechanism, a manager layer is divided into a set of rectangles of the same size, called <span class="emphasis">tiles</span>. The graphic objects that a tile contains are loaded into the application only when that tile becomes visible inside one of the manager views. When a tile is no longer visible in any manager view, it gets unloaded.</div><div id="ww998328" class="Body">A tile is made visible or invisible according to the user’s actions such as moving a map, zooming in or out, activating or deactivating a <span class="emphasis">scale filter</span>, and resizing a window.</div><div id="ww1003540" class="Body">To be divided into tiles, a layer must be of the type <span class="ClassName"><a href="../RefMan/refcppmaps/classIlvTiledLayer.html">IlvTiledLayer</a></span>, a subtype of <span class="ClassName"><a href="../RefMan/refcppmanager/classIlvManagerLayer.html">IlvManagerLayer</a></span>. Tiles are managed by a tile controller (<span class="ClassName"><a href="../RefMan/refcppmaps/classIlvTileController.html">IlvTileController</a></span>) that is associated with a tile loader (<span class="ClassName"><a href="../RefMan/refcppmaps/classIlvTileLoader.html">IlvTileLoader</a></span>) and a tile cache (<span class="ClassName"><a href="../RefMan/refcppmaps/classIlvTileCache.html">IlvTileCache</a></span>). </div><div id="ww1003555" class="Body">Figure&nbsp;4.1 illustrates the classes involved in load-on-demand and how they are related:</div><div class="ww_skin_page_overflow"><div id="ww1003593" class="Startfigure">   <img class="Default" src="../Options/images/loadOnDemandClasses.gif" width="100%" style="display: block; left: 0.0pt; max-height: 221px; max-width: 690px; top: 0.0pt" alt="" /> </div></div><div id="ww998998" class="Caption">The Load-on-Demand Classes</div><div id="ww998956" class="Body">Each time that a tile becomes visible in one of the manager views, the tile controller is notified and the tile lock counter is incremented. If the tile has not been displayed yet, the tile loader is invoked and the data in the tile is loaded into memory. Each time that a tile gets hidden in one of the manager views, its tile lock counter is decremented. When the counter goes to zero, the tile controller places the tile in its associated cache. Each time the tile controller needs to load new tiles, it notifies the cache of this operation and one or more tiles in the cache are unloaded to free memory. A cache can handle tiles that are distributed over several layers belonging to different managers. </div><div id="ww998330" class="Body">To activate the load-on-demand mechanism, the tiled layer must be added to a manager and its <span class="code">start</span> method must be called.</div><div id="ww1004924" class="Body">The <span class="ClassName"><a href="../RefMan/refcppmaps/classIlvTiledLayer.html">IlvTiledLayer</a></span> class has been extended to support load-on-demand for cartographic formats for which Rogue Wave®&nbsp;Views Maps supplies predefined readers, namely CADRG, DTED, and Oracle Spatial. The classes <span class="code">IlvCADRGLayer</span>, <span class="code">IlvDTEDLayer</span>, and <span class="code">IlvSDOLayer</span> are described in <a href="../Options/readers.58.01.html#ww1000266" title="Predefined Readers">Predefined Readers</a>.</div><div id="ww1004928" class="Body">Another useful class for load-on-demand is <span class="ClassName"><a href="../RefMan/refcppmaps/classIlvMapTileLoader.html">IlvMapTileLoader</a></span>. This class allows you to integrate a map reader (<span class="ClassName"><a href="../RefMan/refcppmaps/classIlvMapFeatureIterator.html">IlvMapFeatureIterator</a></span>) in a predefined tile loader. The most important method of this class is the <span class="ClassName"><a href="../RefMan/refcppmaps/classIlvMapTileLoader.html">IlvMapTileLoader</a></span><span class="code">::load</span>() method:</div><div class="ww_skin_page_overflow"><table class="CodeTable" cellspacing="0" summary=""><tr><td style="background-color: #E0E0E0; padding-bottom: 2pt; padding-left: 0pt; padding-right: 0pt; padding-top: 2pt; vertical-align: top; width: 368.503937007874pt"><div id="ww1004733" class="CodeInTable">IlvMapsError</div><div id="ww1004734" class="CodeInTable">IlvMapTileLoader::load(IlvTile* tile)</div><div id="ww1004735" class="CodeInTable">{</div><div id="ww1004736" class="CodeInTable"> // Get the feature iterator. </div><div id="ww1004737" class="CodeInTable"> IlvMapFeatureIterator* iterator = getFeatureIterator(tile);   </div><div id="ww1004738" class="CodeInTable"> ...</div><div id="ww1004739" class="CodeInTable"> // Check if the iterator implements IlvLookAheadFeatureIterator.</div><div id="ww1004740" class="CodeInTable"> ...</div><div id="ww1004741" class="CodeInTable"> // Parameters for rendering.</div><div id="ww1004742" class="CodeInTable"> ...</div><div id="ww1004743" class="CodeInTable"> IlvFeatureRenderer* renderer = getFeatureRenderer(tile-&gt;getDisplay());</div><div id="ww1004744" class="CodeInTable"> ...</div><div id="ww1004745" class="CodeInTable"> do {</div><div id="ww1004746" class="CodeInTable">    // Case of look ahead feature iterator.</div><div id="ww1004747" class="CodeInTable">    // Check if the next feature ID corresponds to an object</div><div id="ww1004748" class="CodeInTable">    // already in the manager (skip the next feature in this</div><div id="ww1004749" class="CodeInTable">    // case and continue).</div><div id="ww1004750" class="CodeInTable">    ...</div><div id="ww1004751" class="CodeInTable">    // Process the feature itself.</div><div id="ww1004752" class="CodeInTable">    ...</div><div id="ww1004753" class="CodeInTable">    feature = iterator-&gt;getNextFeature(); </div><div id="ww1004754" class="CodeInTable">    ...</div><div id="ww1004755" class="CodeInTable">    // Ask the renderer to make the IlvGraphic.</div><div id="ww1004756" class="CodeInTable">    ...</div><div id="ww1004757" class="CodeInTable">    // Attach the attributes to the graphic if necessary</div><div id="ww1004758" class="CodeInTable">    // and add the graphic to the tile.</div><div id="ww1004759" class="CodeInTable">   } while (feature);    </div><div id="ww1004760" class="CodeInTable"> ...</div><div id="ww1004761" class="CodeInTable">}</div></td></tr></table></div><div id="ww1004765" class="Body">In this code sample you can see that the <span class="ClassName"><a href="../RefMan/refcppmaps/classIlvMapFeatureIterator.html">IlvMapFeatureIterator</a></span> class has some optimizations regarding the <span class="ClassName"><a href="../RefMan/refcppmaps/classIlvLookAheadFeatureIterator.html">IlvLookAheadFeatureIterator</a></span> class. Feature iterators subclassing this class can fetch the ID of the next feature that will be returned by the <span class="code">getNextFeature</span> method and skip the next feature. For example, this is useful if a feature has a unique ID and belongs to a group of tiles (case of a large geometry). The first time one of these tiles becomes visible, the feature is read, then rendered, and the corresponding <span class="ClassName"><a href="../RefMan/refcppfoundation/classIlvGraphic.html">IlvGraphic</a></span> is added to the <span class="ClassName"><a href="../RefMan/refcppmaps/classIlvTile.html">IlvTile</a></span> thanks to the <span class="code">IlvTile::addObject(IlvGraphic*, IlvMapFeatureId* )</span> method. Then, when another tile of this group becomes visible, the <span class="code">load</span> method of the <span class="ClassName"><a href="../RefMan/refcppmaps/classIlvMapTileLoader.html">IlvMapTileLoader</a></span> checks through the <span class="code">IlvLookAheadFeatureIterator::getNextFeatureId()</span> method if the returned ID corresponds to an existing <span class="ClassName"><a href="../RefMan/refcppfoundation/classIlvGraphic.html">IlvGraphic</a></span> so that the feature belonging to multiple tiles is loaded, rendered, and added to the tile just once.</div><div id="ww1004767" class="Body">In order to define your own tile loader, you can subclass <span class="ClassName"><a href="../RefMan/refcppmaps/classIlvMapTileLoader.html">IlvMapTileLoader</a></span> and override its <span class="MethodName"><a href="../RefMan/refcppmaps/classIlvMapTileLoader.html#a72e1cdfe115057bd960e74e173bbff54">getFeatureIterator</a></span><span class="code">()</span> method so that it returns your map reader tuned for the specified <span class="ClassName"><a href="../RefMan/refcppmaps/classIlvTile.html">IlvTile</a></span>.</div><div id="ww1005090" class="Body">The following code sample shows an implementation of <span class="ClassName"><a href="../RefMan/refcppmaps/classIlvMapTileLoader.html">IlvMapTileLoader</a></span>. The class <span class="code">MyTileLoader</span> allows you to load a mosaic of the same image in an <span class="ClassName"><a href="../RefMan/refcppmanager/classIlvManager.html">IlvManager</a></span> when it is associated with an <span class="ClassName"><a href="../RefMan/refcppmaps/classIlvTiledLayer.html">IlvTiledLayer</a></span>. </div><div id="ww1004847" class="Body"></div><div class="ww_skin_page_overflow"><table class="CodeTable" cellspacing="0" summary=""><tr><td style="background-color: #E0E0E0; padding-bottom: 2pt; padding-left: 0pt; padding-right: 0pt; padding-top: 2pt; vertical-align: top; width: 371.338299212598pt"><div id="ww1004774" class="CodeInTable">		</div><div id="ww1004775" class="CodeInTable">class MyTileLoader:public IlvMapTileLoader</div><div id="ww1004776" class="CodeInTable">{</div><div id="ww1004777" class="CodeInTable">    IlvDisplay* _display;</div><div id="ww1004778" class="CodeInTable">    const char* _filename; // The filename that corresponds to the image </div><div id="ww1004779" class="CodeInTable">                           // its format should be known by Rogue Wave&nbsp;Views.</div><div id="ww1004780" class="CodeInTable">    IlvProjection* _projection;</div><div id="ww1004781" class="CodeInTable">    IlvMapInfo* _info;</div><div id="ww1004782" class="CodeInTable">    IlvDim _imageWidth;</div><div id="ww1004783" class="CodeInTable">    IlvDim _imageHeight;</div><div id="ww1004784" class="CodeInTable">&nbsp;</div><div id="ww1004785" class="CodeInTable">public:</div><div id="ww1004786" class="CodeInTable">    MyTileLoader(IlvDisplay* display, const char* filename)</div><div id="ww1004787" class="CodeInTable">      _display(display),</div><div id="ww1004788" class="CodeInTable">      _filename(IlvMapDataPathManager::ResolvePath(filename)),</div><div id="ww1004789" class="CodeInTable">      _projection(new IlvGeographicProjection()),</div><div id="ww1004790" class="CodeInTable">      _info(0),</div><div id="ww1004791" class="CodeInTable">      _imageWidth(0),</div><div id="ww1004792" class="CodeInTable">      _imageHeight(0)</div><div id="ww1004793" class="CodeInTable">    {</div><div id="ww1004794" class="CodeInTable">        //Creation of the IlvBitmap corresponding to the given filename.</div><div id="ww1004795" class="CodeInTable">        IlvBitmap* bitmap = </div><div id="ww1004796" class="CodeInTable">           display-&gt;readBitmap(IlvMapDataPathManager::ResolvePath(filename));	</div><div id="ww1004797" class="CodeInTable">        if(bitmap) { </div><div id="ww1004798" class="CodeInTable">            _imageWidth = bitmap-&gt;width();</div><div id="ww1004799" class="CodeInTable">            _imageHeight = bitmap-&gt;height();</div><div id="ww1004800" class="CodeInTable">        }</div><div id="ww1004801" class="CodeInTable">    }</div><div id="ww1004802" class="CodeInTable">&nbsp;</div><div id="ww1004803" class="CodeInTable">    ~MyTileLoader()</div><div id="ww1004804" class="CodeInTable">    {</div><div id="ww1004805" class="CodeInTable">        if(_info)</div><div id="ww1004806" class="CodeInTable">            delete _info;</div><div id="ww1004807" class="CodeInTable">    }</div><div id="ww1004808" class="CodeInTable">    </div><div id="ww1004809" class="CodeInTable">    IlBoolean isPersistent() const {</div><div id="ww1004810" class="CodeInTable">        return IlFalse;</div><div id="ww1004811" class="CodeInTable">    }</div><div id="ww1004812" class="CodeInTable">&nbsp;</div><div id="ww1004813" class="CodeInTable">    IlvMapFeatureIterator* getFeatureIterator(IlvTile* tile)</div><div id="ww1004814" class="CodeInTable">    {</div><div id="ww1004815" class="CodeInTable">        IlvRect rect;</div><div id="ww1004816" class="CodeInTable">        tile-&gt;boundingBox(rect);</div><div id="ww1004817" class="CodeInTable">        IlvMapInfo* info = getMapInfo();</div><div id="ww1004818" class="CodeInTable">        IlvCoordinate ul;</div><div id="ww1004819" class="CodeInTable">        IlvCoordinate lr;</div><div id="ww1004820" class="CodeInTable">        IlvPoint p1(rect.x(), rect.y());</div><div id="ww1004821" class="CodeInTable">        IlvPoint p2(rect.x() + rect.w(), rect.y() - rect.h());</div><div id="ww1004822" class="CodeInTable">        ul = info-&gt;getAdapter()-&gt;fromViews(p1);</div><div id="ww1004823" class="CodeInTable">        lr = info-&gt;getAdapter()-&gt;fromViews(p2);</div><div id="ww1004824" class="CodeInTable">        return new IlvImageReader(_display, _filename, ul, lr);</div><div id="ww1004825" class="CodeInTable">    }</div></td></tr></table></div><div class="ww_skin_page_overflow"><table class="CodeTable" cellspacing="0" summary=""><tr><td style="background-color: #E0E0E0; padding-bottom: 2pt; padding-left: 0pt; padding-right: 0pt; padding-top: 2pt; vertical-align: top; width: 371.338299212598pt"><div id="ww1004829" class="CodeInTable">    IlvFeatureRenderer* getDefaultFeatureRenderer(IlvDisplay* display)</div><div id="ww1004830" class="CodeInTable">    {</div><div id="ww1004831" class="CodeInTable">        return new IlvDefaultFeatureRenderer(display);</div><div id="ww1004832" class="CodeInTable">    }</div><div id="ww1004833" class="CodeInTable">&nbsp;</div><div id="ww1004834" class="CodeInTable">    IlvMapInfo* getMapInfo()</div><div id="ww1004835" class="CodeInTable">    {</div><div id="ww1004836" class="CodeInTable">        if (!_info)</div><div id="ww1004837" class="CodeInTable">            _info = new IlvMapInfo(_projection);</div><div id="ww1004838" class="CodeInTable">        return _info;</div><div id="ww1004839" class="CodeInTable">    }</div><div id="ww1004840" class="CodeInTable">&nbsp;</div><div id="ww1004841" class="CodeInTable">    IlvRect getTileOrigin() </div><div id="ww1004842" class="CodeInTable">    {</div><div id="ww1004843" class="CodeInTable">        return IlvRect(0, 0, _imageWidth, _imageHeight);</div><div id="ww1004844" class="CodeInTable">    }</div><div id="ww1004845" class="CodeInTable">};</div><div id="ww1004846" class="CodeInTable">&nbsp;</div></td></tr></table></div><div id="ww1004849" class="Body">In this code sample, note the following line: <span class="code">IlvMapDataPathManager::ResolvePath(filename)</span></div><div id="ww1005093" class="Body">The data path management feature allows you to resolve a relative path name. </div><div id="ww1004850" class="Body">For example, an <span class="code">.ilv</span> file may contain tile loaders that reference files (such as Shapefile, GeoTIFF file, and so on). If these references are relative path names, they can be easily resolved thanks to a default resolver. For example, if the files needed by the tile loaders are located in “<span class="code">c:\data</span>”, then all you have to do is call: </div><div class="ww_skin_page_overflow"><table class="CodeTable" cellspacing="0" summary=""><tr><td style="background-color: #E0E0E0; padding-bottom: 2pt; padding-left: 0pt; padding-right: 0pt; padding-top: 2pt; vertical-align: top; width: 371.338299212598pt"><div id="ww1004853" class="CodeInTable" style="color: #000000; font-style: normal; font-variant: normal; font-weight: normal; text-transform: none; vertical-align: baseline"><span class="code">IlvDefaultDataPathResolver* resolver = </span></div><div id="ww1004854" class="CodeInTable"><span class="code">                         new IlvDefaultDataPathResolver(</span><span style="font-family: &quot;Times New Roman&quot;; font-size: 10.0pt">“</span><span class="code">c:\\data</span><span style="font-family: &quot;Times New Roman&quot;; font-size: 10.0pt">”</span><span class="code">);</span></div><div id="ww1004855" class="CodeInTable" style="color: #000000; font-style: normal; font-variant: normal; font-weight: normal; text-transform: none; vertical-align: baseline"><span class="code">IlvMapDataPathManager::AddDataPathResolver(resolver);</span></div></td></tr></table></div><div id="ww1004722" class="Body">This is a static function that can be called whenever before the <span class="code">.ilv</span> file is read. Of course, it only works if the tile loader saved in the <span class="code">.ilv</span> file uses <span class="code">IlvMapDataPathManager::ResolvePath(const char* filename)</span> in order to resolve path names (see the sample code above).</div><footer><!-- Related Topics --><!--                --><!-- Disqus --><!--        --><!-- Google Translation --><!--                    --><div class="ww_skin_page_globalization"><div id="google_translate_element">&nbsp;</div><script><!--
            function googleTranslateElementInit() {
              new google.translate.TranslateElement({
                  pageLanguage: '',
                  autoDisplay: true
                }, 'google_translate_element');
            }
// --></script></div><br /></footer><HR /><div style="font-size: 8pt; font-family: verdana; font-weight: normal; text-align: center;">Version 6.2.1</div><div style="font-size: 8pt; font-family: verdana; font-weight: normal; text-align: center;">Copyright © 2018, Rogue Wave Software, Inc. All Rights Reserved.</div></body></html>